## 자료구조

## Array (배열)
같은 형의 데이터 타입을 메모리에 저장하는 선형적 자료 구조.  
논리적 구조와 물리적 구조가 동일합니다  
1. fixed - length
2. index 연산이 빠르다  
 element의 위치를 찾는 속도가 빠르다  
3. insert / delete 연산이 느리다  
 배열의 길이에 연산속도가 종속되있다  


JDK : ArrayList, Vector  
 * Vector는 멀티쓰레드를 위한 동기화를 지원한다
 
## 배열의 단점을 보완한 LinkedList  
배열과는 달리 논리적 구조와 물리적 구조가 불일치  
element와 다음 element의 주소를 가리키는 link로 구성  
새로운 element가 insert / delete 될 때 배열과는 달리 link의 내용만 바꾸면 된다  
1. insert / delete 연산이 빠르다
2. index 연산이 느리다 


JDK : LinkedList

## Stack (스택)
- ex) 바둑 / 장기 의 무르기 기능

LIFO의 구조 (Last in First out)  
element를 추가 -> push() / elements를 제거 -> pop()  
제일 최근의 element를 top이라고 표현함  

ㅁ -> top  
ㅁ  
ㅁ  
ㅁ  
ㅁ

peek() : top을 반환 ( get()과 유사 )

JDK : Stack, ArrayList의 활용

## Queue (큐)
- 대기열 구조


FIFO의 구조 (First in First out)  
front ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ rear  
element를 추가할때는 rear로 들어오고 ( enqueue() )  
element를 제거할때는 front로 나간다 ( dequeue() )  

JDK : ArrayList, Vector, LinkedList의 활용

#Tree 
Binary Search Tree : 자식노드의 수가 최대 2개인 자료 구조  

상위 node : parent node  
하위 node : left child node, right child node 

 * 검색을 위한 구조 
 * parent node를 중심으로 왼쪽에 있는 수는 parent node보다 작은수
 * 오른쪽에 있는 수는 parent node보다 큰 수
 * 중복을 허용하지 않음 - key value가 동일한 수가 존재하지 않는다  
 
 정렬 방법
 * in order (search order : left - me - right) 오름차순 정렬
 * pre order
 * post order
 
 JDK : Treeset, TreeMap(Red - Black Tree)
 
#Hashing
key value의 산술 연산을 이용한 검색 방식  
hashcode() : JVM이 인스턴스를 관리하기 위해 만든 hash value  
자료가 N개 일때의 시간복잡도 : O(1) = 빠르다

index = h(key)  
Key -> Hashing Function -> Address => Hash Table의 index를 나타낸다  
Hashing Function의 완성도에 따라 Collision 관리의 난이도, 알고리즘의 수행속도가 달라진다

 JDK : HashMap, HashSet
